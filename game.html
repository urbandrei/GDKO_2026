<!DOCTYPE html>
<html>
<head>
    <title>Game</title>
</head>
<body style="margin:0;overflow:hidden;">
    <div id="home" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;">
        <h1>GDKO 2026 prototype 1.0</h1>
        <button onclick="startGame()">Start Game</button>
    </div>
    <div id="gameover" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;display:none;">
        <h1>Game Over</h1>
        <button onclick="startGame()">Restart</button>
        <button onclick="goHome()">Home</button>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const PLAYER_SIZE = 30;
        const PLAYER_SPEED = 200;
        const BULLET_SIZE = 8;
        const BULLET_SPEED = 500;
        const BULLET_MAX_DISTANCE = 600;
        const FIRE_RATE = 1000;
        const ENEMY_SIZE = 25;
        const ENEMY_HITBOX = 35;
        const ENEMY_SPEED = 120;
        const SPAWN_INTERVAL = 1500;
        const FRAGMENT_COUNT_MIN = 3;
        const FRAGMENT_COUNT_MAX = 4;
        const FRAGMENT_SIZE = 8;
        const FRAGMENT_SPEED_MIN = 450;
        const FRAGMENT_SPEED_MAX = 550;
        const FRAGMENT_LIFETIME = 500;
        const FRAGMENT_CONE = Math.PI / 3;
        const FRAGMENT_MOVE_TIME = 200;
        const FRAGMENT_FADE_TIME = 300;
        const SHAKE_INTENSITY = 3;
        const SHAKE_DURATION = 100;
        const HITSTOP_DURATION = 20;
        const RECOIL_DISTANCE = 4;
        const BODY_SLAM_KNOCKBACK = 50;
        const RECOIL_RECOVERY = 0.15;
        const MUZZLE_FLASH_SIZE = 12;
        const MUZZLE_FLASH_DURATION = 50;
        const TRAIL_LENGTH = 5;
        const ENEMY_DEATH_DURATION = 100;
        const ENEMY_DEATH_SCALE = 1.25;
        const GRASS_COLOR = '#5a7a5a';
        const GRASS_CHARS = ['\\', '|', '/'];
        const GRASS_WAVE_SPEED = 0.003;
        const GRASS_CELL_SIZE = 100;
        const CARD_DROP_CHANCE = 0.1;
        const CARD_DESPAWN_TIME = 10000;
        const CARD_WIDTH = 30;
        const CARD_HEIGHT = 40;
        const CARD_EFFECTS = [
            { id: 'circle', name: 'Circle Player', desc: 'Round corners' },
            { id: 'square', name: 'Square Player', desc: 'Sharpen corners' },
            { id: 'red', name: 'Red Player', desc: 'Add red tint' },
            { id: 'green', name: 'Green Player', desc: 'Add green tint' },
            { id: 'blue', name: 'Blue Player', desc: 'Add blue tint' },
            { id: 'extraBullet', name: 'Extra Bullet', desc: '+1 bullet per shot' },
            { id: 'homing', name: 'Homing Bullets', desc: 'Bullets seek enemies' },
            { id: 'piercing', name: 'Piercing Bullets', desc: 'Go through enemies' },
            { id: 'damage', name: 'Bullet Damage', desc: '+1 damage per bullet' },
            { id: 'bulletSpeed', name: 'Bullet Speed', desc: '+25% bullet speed' },
            { id: 'fireRate', name: 'Fire Rate', desc: '+25% fire rate' }
        ];
        const CARD_UI_WIDTH = 150;
        const CARD_UI_HEIGHT = 200;
        const HOMING_STRENGTH = 2;
        const CARD_PICKUP_ANIM_DURATION = 300;
        const CARD_UI_WIDTH_NEW = 250;
        const CARD_UI_HEIGHT_NEW = 350;
        const MINI_CARD_SIZE = 40;
        const MINI_CARD_MARGIN = 5;
        const CARD_VIEW_PLAYER_X = 0.6;
        const CARD_VIEW_CARD_X = 0.4;
        const ENEMY_BASE_HEALTH = 1;
        const ENEMY_BULLET_SIZE = 10;
        const ENEMY_BULLET_SPEED = 300;
        const ENEMY_FIRE_RATE_BASE = 2500;
        const PLAYER_INVINCIBILITY_TIME = 1000;
        const DIFFICULTY_RAMP_TIME = 180000;
        const CARD_VIEW_TIMEOUT = 5000;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const homeScreen = document.getElementById('home');
        const gameoverScreen = document.getElementById('gameover');

        let gameState = 'home';
        let player = { x: 0, y: 0 };
        let bullets = [];
        let enemies = [];
        let fragments = [];
        let keys = {};
        let mouse = { x: 0, y: 0, down: false };
        let lastShot = 0;
        let lastSpawn = 0;
        let lastTime = 0;
        let shake = { x: 0, y: 0, until: 0 };
        let hitstopUntil = 0;
        let recoil = { x: 0, y: 0 };
        let muzzleFlash = { until: 0 };
        let cards = [];
        let viewingCard = null;
        let activeEffects = [];
        let draggingCard = false;
        let dragPos = { x: 0, y: 0 };
        let cardAnimation = { active: false, startTime: 0, cardStartWorldX: 0, cardStartWorldY: 0 };
        let activatedCards = [];
        let enemyBullets = [];
        let playerInvincibleUntil = 0;
        let gameStartTime = 0;
        let cardViewStartTime = 0;

        function seededRandom(x, y) {
            const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
            return n - Math.floor(n);
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            if (draggingCard && viewingCard) {
                dragPos.x = mouse.x - CARD_UI_WIDTH_NEW / 2;
                dragPos.y = mouse.y - CARD_UI_HEIGHT_NEW / 2;
            }
        });
        window.addEventListener('mousedown', e => {
            mouse.down = true;
            if (viewingCard && !cardAnimation.active) {
                // Use the resting card position
                const cardX = canvas.width * CARD_VIEW_CARD_X - CARD_UI_WIDTH_NEW / 2;
                const cardY = canvas.height * 0.5 - CARD_UI_HEIGHT_NEW / 2;
                const cardRight = cardX + CARD_UI_WIDTH_NEW;
                const cardBottom = cardY + CARD_UI_HEIGHT_NEW;
                if (mouse.x >= cardX && mouse.x <= cardRight && mouse.y >= cardY && mouse.y <= cardBottom) {
                    draggingCard = true;
                    dragPos.x = cardX;
                    dragPos.y = cardY;
                }
            }
        });
        window.addEventListener('mouseup', () => {
            mouse.down = false;
            if (viewingCard && draggingCard) {
                if (mouse.y > canvas.height - 100) {
                    // Activated - apply effect and dismiss
                    activeEffects.push(viewingCard.effect.id);
                    const letter = viewingCard.effect.name.charAt(0).toUpperCase();
                    activatedCards.push({ effectId: viewingCard.effect.id, letter: letter });
                    viewingCard = null;
                    cardAnimation.active = false;
                }
                // If not in activation zone, just stop dragging (timer will handle dismiss)
                draggingCard = false;
            }
        });

        function startGame() {
            player = { x: 0, y: 0 };
            bullets = [];
            enemies = [];
            fragments = [];
            cards = [];
            activeEffects = [];
            activatedCards = [];
            viewingCard = null;
            draggingCard = false;
            cardAnimation = { active: false, startTime: 0, cardStartWorldX: 0, cardStartWorldY: 0 };
            enemyBullets = [];
            playerInvincibleUntil = 0;
            gameStartTime = performance.now();
            cardViewStartTime = 0;
            keys = {};
            lastShot = 0;
            lastSpawn = 0;
            shake = { x: 0, y: 0, until: 0 };
            hitstopUntil = 0;
            recoil = { x: 0, y: 0 };
            muzzleFlash = { until: 0 };
            gameState = 'playing';
            homeScreen.style.display = 'none';
            gameoverScreen.style.display = 'none';
            canvas.style.cursor = 'none';
        }

        function goHome() {
            gameState = 'home';
            homeScreen.style.display = 'block';
            gameoverScreen.style.display = 'none';
            canvas.style.cursor = 'default';
        }

        function gameOver() {
            gameState = 'gameover';
            gameoverScreen.style.display = 'block';
            canvas.style.cursor = 'default';
        }

        function triggerShake(intensity, now) {
            shake.x = (Math.random() - 0.5) * 2 * intensity;
            shake.y = (Math.random() - 0.5) * 2 * intensity;
            shake.until = now + SHAKE_DURATION;
        }

        function shoot(now) {
            if (now - lastShot < FIRE_RATE) return;
            lastShot = now;

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const dx = mouse.x - cx;
            const dy = mouse.y - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist === 0) return;

            const dirX = dx / dist;
            const dirY = dy / dist;
            const extraCount = activeEffects.filter(e => e === 'extraBullet').length;
            const damageCount = activeEffects.filter(e => e === 'damage').length;
            const speedCount = activeEffects.filter(e => e === 'bulletSpeed').length;
            const isPiercing = activeEffects.includes('piercing');
            const bulletDamage = 1 + damageCount;
            const bulletSpeedMult = Math.pow(1.25, speedCount);
            const actualBulletSpeed = BULLET_SPEED * bulletSpeedMult;
            const totalBullets = 1 + extraCount;
            const spreadAngle = 0.15; // radians between bullets

            for (let i = 0; i < totalBullets; i++) {
                const angleOffset = (i - (totalBullets - 1) / 2) * spreadAngle;
                const cos = Math.cos(angleOffset);
                const sin = Math.sin(angleOffset);
                const bDirX = dirX * cos - dirY * sin;
                const bDirY = dirX * sin + dirY * cos;
                const startX = player.x + bDirX * (PLAYER_SIZE / 2 + BULLET_SIZE);
                const startY = player.y + bDirY * (PLAYER_SIZE / 2 + BULLET_SIZE);
                bullets.push({
                    x: startX,
                    y: startY,
                    startX: startX,
                    startY: startY,
                    vx: bDirX * actualBulletSpeed,
                    vy: bDirY * actualBulletSpeed,
                    trail: [],
                    damage: bulletDamage,
                    piercing: isPiercing,
                    hitEnemies: new Set()
                });
            }

            triggerShake(SHAKE_INTENSITY * 0.5, now);
            recoil.x = -dirX * RECOIL_DISTANCE;
            recoil.y = -dirY * RECOIL_DISTANCE;
            muzzleFlash.until = now + MUZZLE_FLASH_DURATION;
            muzzleFlash.offsetX = dirX * (PLAYER_SIZE / 2 + MUZZLE_FLASH_SIZE / 2);
            muzzleFlash.offsetY = dirY * (PLAYER_SIZE / 2 + MUZZLE_FLASH_SIZE / 2);
        }

        function spawnEnemy(now) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.max(canvas.width, canvas.height) / 2 + 100;
            const diff = getDifficultyMult(now);
            enemies.push({
                x: player.x + Math.cos(angle) * dist,
                y: player.y + Math.sin(angle) * dist,
                health: Math.ceil(ENEMY_BASE_HEALTH * diff),
                lastShot: now,
                fireRate: ENEMY_FIRE_RATE_BASE / diff
            });
        }

        function spawnFragments(ex, ey, bvx, bvy, now) {
            const baseAngle = Math.atan2(bvy, bvx);
            const count = FRAGMENT_COUNT_MIN + Math.floor(Math.random() * (FRAGMENT_COUNT_MAX - FRAGMENT_COUNT_MIN + 1));
            for (let i = 0; i < count; i++) {
                const angle = baseAngle + (Math.random() - 0.5) * FRAGMENT_CONE;
                const speed = FRAGMENT_SPEED_MIN + Math.random() * (FRAGMENT_SPEED_MAX - FRAGMENT_SPEED_MIN);
                fragments.push({
                    x: ex,
                    y: ey,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    birth: now
                });
            }
        }

        function checkCollision(ax, ay, aSize, bx, by, bSize) {
            return Math.abs(ax - bx) < (aSize + bSize) / 2 &&
                   Math.abs(ay - by) < (aSize + bSize) / 2;
        }

        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }

        function getCardScale() {
            if (!draggingCard) return 1.0;
            const restingY = canvas.height * 0.5;
            const dropZoneY = canvas.height - 100;
            const cardCenterY = dragPos.y + CARD_UI_HEIGHT_NEW / 2;
            const progress = Math.max(0, Math.min(1, (cardCenterY - restingY) / (dropZoneY - restingY)));
            const minScale = MINI_CARD_SIZE / CARD_UI_WIDTH_NEW;
            return 1.0 - (1.0 - minScale) * progress;
        }

        function shouldShowCardText() {
            return getCardScale() > 0.5;
        }

        function getDifficultyMult(now) {
            const elapsed = now - gameStartTime;
            // Exponential scaling: starts at 0.7, doubles every DIFFICULTY_RAMP_TIME (3 min)
            return 0.7 * Math.pow(2, elapsed / DIFFICULTY_RAMP_TIME);
        }

        function mixColors(r, g, b) {
            const total = r + g + b;
            if (total === 0) return 'black';
            // Paint-style mixing approximation
            const rNorm = r / total;
            const gNorm = g / total;
            const bNorm = b / total;
            // Red + Blue = Purple, Red + Green = Brown/Yellow, Blue + Green = Teal
            const red = Math.floor(255 * rNorm);
            const green = Math.floor(255 * gNorm);
            const blue = Math.floor(255 * bNorm);
            return `rgb(${red}, ${green}, ${blue})`;
        }

        function drawRoundedRect(cx, cy, size, radius, recoilX, recoilY) {
            const half = size / 2;
            const x = cx - half + recoilX;
            const y = cy - half + recoilY;
            if (radius >= half) {
                ctx.beginPath();
                ctx.arc(cx + recoilX, cy + recoilY, half, 0, Math.PI * 2);
                ctx.fill();
                return;
            }
            if (radius <= 0) {
                ctx.fillRect(x, y, size, size);
                return;
            }
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + size - radius, y);
            ctx.quadraticCurveTo(x + size, y, x + size, y + radius);
            ctx.lineTo(x + size, y + size - radius);
            ctx.quadraticCurveTo(x + size, y + size, x + size - radius, y + size);
            ctx.lineTo(x + radius, y + size);
            ctx.quadraticCurveTo(x, y + size, x, y + size - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        }

        function update(dt, now) {
            let moveX = 0, moveY = 0;
            if (keys['w']) moveY -= 1;
            if (keys['s']) moveY += 1;
            if (keys['a']) moveX -= 1;
            if (keys['d']) moveX += 1;
            const moveDist = Math.sqrt(moveX * moveX + moveY * moveY);
            if (moveDist > 0) {
                player.x += (moveX / moveDist) * PLAYER_SPEED * dt;
                player.y += (moveY / moveDist) * PLAYER_SPEED * dt;
            }

            if (mouse.down) shoot(now);

            const diff = getDifficultyMult(now);
            if (now - lastSpawn > SPAWN_INTERVAL / diff) {
                lastSpawn = now;
                spawnEnemy(now);
            }

            recoil.x *= (1 - RECOIL_RECOVERY);
            recoil.y *= (1 - RECOIL_RECOVERY);

            const homingCount = activeEffects.filter(e => e === 'homing').length;
            for (let b of bullets) {
                const distFromPlayer = Math.sqrt((b.x - player.x) ** 2 + (b.y - player.y) ** 2);
                if (distFromPlayer > PLAYER_SIZE) {
                    b.trail.push({ x: b.x, y: b.y });
                    if (b.trail.length > TRAIL_LENGTH) b.trail.shift();
                }

                // Homing
                if (homingCount > 0) {
                    let nearestEnemy = null;
                    let nearestDist = Infinity;
                    for (let e of enemies) {
                        if (e.dying) continue;
                        const d = Math.sqrt((b.x - e.x) ** 2 + (b.y - e.y) ** 2);
                        if (d < nearestDist) {
                            nearestDist = d;
                            nearestEnemy = e;
                        }
                    }
                    if (nearestEnemy) {
                        const tdx = nearestEnemy.x - b.x;
                        const tdy = nearestEnemy.y - b.y;
                        const tDist = Math.sqrt(tdx * tdx + tdy * tdy);
                        if (tDist > 0) {
                            const strength = HOMING_STRENGTH * homingCount;
                            b.vx += (tdx / tDist) * strength;
                            b.vy += (tdy / tDist) * strength;
                            const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
                            b.vx = (b.vx / speed) * BULLET_SPEED;
                            b.vy = (b.vy / speed) * BULLET_SPEED;
                        }
                    }
                }

                b.x += b.vx * dt;
                b.y += b.vy * dt;
            }

            for (let e of enemies) {
                if (e.dying) continue;
                const dx = player.x - e.x;
                const dy = player.y - e.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0) {
                    e.x += (dx / dist) * ENEMY_SPEED * diff * dt;
                    e.y += (dy / dist) * ENEMY_SPEED * diff * dt;
                    // Enemy shooting
                    if (now - e.lastShot > e.fireRate) {
                        e.lastShot = now;
                        enemyBullets.push({
                            x: e.x,
                            y: e.y,
                            vx: (dx / dist) * ENEMY_BULLET_SPEED * (0.8 + diff * 0.2),
                            vy: (dy / dist) * ENEMY_BULLET_SPEED * (0.8 + diff * 0.2),
                            trail: []
                        });
                    }
                }
            }

            // Move enemy bullets
            for (let b of enemyBullets) {
                b.trail.push({ x: b.x, y: b.y });
                if (b.trail.length > TRAIL_LENGTH) b.trail.shift();
                b.x += b.vx * dt;
                b.y += b.vy * dt;
            }
            // Remove off-screen enemy bullets
            enemyBullets = enemyBullets.filter(b => {
                const dx = b.x - player.x;
                const dy = b.y - player.y;
                return Math.sqrt(dx*dx + dy*dy) < 1500;
            });

            // Player bullets destroy enemy bullets
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const eb = enemyBullets[i];
                for (let j = bullets.length - 1; j >= 0; j--) {
                    const pb = bullets[j];
                    if (checkCollision(eb.x, eb.y, ENEMY_BULLET_SIZE, pb.x, pb.y, BULLET_SIZE)) {
                        enemyBullets.splice(i, 1);
                        if (!pb.piercing) {
                            bullets.splice(j, 1);
                        }
                        break;
                    }
                }
            }

            bullets = bullets.filter(b => {
                const dist = Math.sqrt((b.x - b.startX) ** 2 + (b.y - b.startY) ** 2);
                return dist < BULLET_MAX_DISTANCE;
            });

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                if (e.dying) continue;
                for (let j = bullets.length - 1; j >= 0; j--) {
                    const b = bullets[j];
                    // Skip if piercing bullet already hit this enemy
                    if (b.piercing && b.hitEnemies.has(i)) continue;
                    if (checkCollision(e.x, e.y, ENEMY_HITBOX, b.x, b.y, BULLET_SIZE)) {
                        e.health -= b.damage;
                        // Hit feedback: white flash and pushback
                        e.hitFlashUntil = now + 50;
                        const bSpeed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
                        if (bSpeed > 0) {
                            e.x += (b.vx / bSpeed) * 10;
                            e.y += (b.vy / bSpeed) * 10;
                        }
                        if (e.health <= 0) {
                            e.dying = true;
                            e.deathTime = now;
                            e.killVx = b.vx;
                            e.killVy = b.vy;
                            spawnFragments(e.x, e.y, b.vx, b.vy, now);
                            triggerShake(SHAKE_INTENSITY, now);
                            hitstopUntil = now + HITSTOP_DURATION;
                        }
                        if (b.piercing) {
                            b.hitEnemies.add(i);
                        } else {
                            bullets.splice(j, 1);
                        }
                        break;
                    }
                }
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                if (e.dying && now - e.deathTime >= ENEMY_DEATH_DURATION) {
                    if (Math.random() < CARD_DROP_CHANCE) {
                        const effect = CARD_EFFECTS[Math.floor(Math.random() * CARD_EFFECTS.length)];
                        cards.push({ x: e.x, y: e.y, effect: effect, spawnTime: now });
                    }
                    enemies.splice(i, 1);
                }
            }

            // Player hit by enemy bullets
            if (now >= playerInvincibleUntil) {
                for (let i = enemyBullets.length - 1; i >= 0; i--) {
                    const b = enemyBullets[i];
                    if (checkCollision(player.x, player.y, PLAYER_SIZE, b.x, b.y, ENEMY_BULLET_SIZE)) {
                        enemyBullets.splice(i, 1);
                        if (activatedCards.length > 0) {
                            const removed = activatedCards.pop();
                            const idx = activeEffects.lastIndexOf(removed.effectId);
                            if (idx !== -1) activeEffects.splice(idx, 1);
                            playerInvincibleUntil = now + PLAYER_INVINCIBILITY_TIME;
                        } else {
                            gameOver();
                            return;
                        }
                    }
                }
            }

            for (let e of enemies) {
                if (e.dying) continue;
                if (checkCollision(player.x, player.y, PLAYER_SIZE, e.x, e.y, ENEMY_HITBOX)) {
                    // 1. Damage enemy by 1
                    e.health -= 1;
                    e.hitFlashUntil = now + 50;

                    // 2. Knock enemy back significantly (away from player)
                    const dx = e.x - player.x;
                    const dy = e.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) {
                        e.x += (dx / dist) * BODY_SLAM_KNOCKBACK;
                        e.y += (dy / dist) * BODY_SLAM_KNOCKBACK;
                    }

                    // 3. Check if enemy dies
                    if (e.health <= 0) {
                        e.dying = true;
                        e.deathTime = now;
                        e.killVx = dx;
                        e.killVy = dy;
                        spawnFragments(e.x, e.y, dx, dy, now);
                        triggerShake(SHAKE_INTENSITY, now);
                        hitstopUntil = now + HITSTOP_DURATION;
                    }

                    // 4. Player takes damage (no invincibility)
                    if (activatedCards.length > 0) {
                        const removed = activatedCards.pop();
                        const idx = activeEffects.lastIndexOf(removed.effectId);
                        if (idx !== -1) activeEffects.splice(idx, 1);
                    } else {
                        gameOver();
                        return;
                    }
                }
            }

            for (let f of fragments) {
                const age = now - f.birth;
                if (age < FRAGMENT_MOVE_TIME) {
                    const factor = 1 - age / FRAGMENT_MOVE_TIME;
                    f.x += f.vx * factor * dt;
                    f.y += f.vy * factor * dt;
                }
            }
            fragments = fragments.filter(f => now - f.birth < FRAGMENT_LIFETIME);

            // Card pickup
            for (let i = cards.length - 1; i >= 0; i--) {
                const c = cards[i];
                if (checkCollision(player.x, player.y, PLAYER_SIZE, c.x, c.y, CARD_WIDTH)) {
                    viewingCard = c;
                    cardAnimation.active = true;
                    cardAnimation.startTime = now;
                    cardAnimation.cardStartWorldX = c.x;
                    cardAnimation.cardStartWorldY = c.y;
                    cardViewStartTime = now;
                    draggingCard = false;
                    cards.splice(i, 1);
                    break;
                }
            }

            // Card despawn
            cards = cards.filter(c => now - c.spawnTime < CARD_DESPAWN_TIME);
        }

        function render(now) {
            ctx.fillStyle = '#ccc';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            // Shake decay
            let shakeX = 0, shakeY = 0;
            if (now < shake.until) {
                const t = (shake.until - now) / SHAKE_DURATION;
                shakeX = shake.x * t;
                shakeY = shake.y * t;
            }

            // Zoom and offset when viewing card
            let zoom = 1;
            let playerScreenX = cx;
            let playerScreenY = cy;
            let animProgress = 1.0;

            if (viewingCard) {
                // Calculate animation progress
                if (cardAnimation.active) {
                    const elapsed = now - cardAnimation.startTime;
                    animProgress = Math.min(1.0, elapsed / CARD_PICKUP_ANIM_DURATION);
                    animProgress = easeOutCubic(animProgress);
                    if (elapsed >= CARD_PICKUP_ANIM_DURATION) {
                        cardAnimation.active = false;
                    }
                }

                // Interpolate zoom and player position
                const targetZoom = 1.8;
                zoom = 1 + (targetZoom - 1) * animProgress;
                playerScreenX = cx + (canvas.width * CARD_VIEW_PLAYER_X - cx) * animProgress;
                playerScreenY = cy; // stays centered vertically
            }

            ctx.save();
            if (viewingCard) {
                ctx.translate(playerScreenX, playerScreenY);
                ctx.scale(zoom, zoom);
                ctx.translate(-playerScreenX, -playerScreenY);
            }

            const offsetX = player.x - playerScreenX + shakeX;
            const offsetY = player.y - playerScreenY + shakeY;

            // Grass (procedurally generated based on grid cells)
            ctx.fillStyle = GRASS_COLOR;
            ctx.font = '16px monospace';
            const startCellX = Math.floor((player.x - cx) / GRASS_CELL_SIZE) - 1;
            const startCellY = Math.floor((player.y - cy) / GRASS_CELL_SIZE) - 1;
            const endCellX = Math.ceil((player.x + cx) / GRASS_CELL_SIZE) + 1;
            const endCellY = Math.ceil((player.y + cy) / GRASS_CELL_SIZE) + 1;
            for (let cellX = startCellX; cellX <= endCellX; cellX++) {
                for (let cellY = startCellY; cellY <= endCellY; cellY++) {
                    const rand = seededRandom(cellX, cellY);
                    if (rand > 0.3) continue; // sparse grass
                    const gx = cellX * GRASS_CELL_SIZE + rand * GRASS_CELL_SIZE;
                    const gy = cellY * GRASS_CELL_SIZE + seededRandom(cellY, cellX) * GRASS_CELL_SIZE;
                    const screenX = gx - offsetX;
                    const screenY = gy - offsetY;
                    const phase = Math.sin(gx * 0.01 + now * GRASS_WAVE_SPEED);
                    const charIndex = phase < -0.33 ? 0 : phase > 0.33 ? 2 : 1;
                    ctx.fillText(GRASS_CHARS[charIndex], screenX, screenY);
                }
            }

            // Player with recoil
            // Determine if previewing effect (when dragging card down)
            let previewEffect = null;
            if (viewingCard && draggingCard) {
                const effectId = viewingCard.effect.id;
                if (['green', 'red', 'blue', 'circle', 'square'].includes(effectId)) {
                    previewEffect = effectId;
                }
            }

            // Count color cards (including preview)
            let redCount = activeEffects.filter(e => e === 'red').length;
            let greenCount = activeEffects.filter(e => e === 'green').length;
            let blueCount = activeEffects.filter(e => e === 'blue').length;
            if (previewEffect === 'red') redCount++;
            if (previewEffect === 'green') greenCount++;
            if (previewEffect === 'blue') blueCount++;
            const playerColor = mixColors(redCount, greenCount, blueCount);
            ctx.fillStyle = playerColor;

            // Count shape cards (including preview)
            let circleCount = activeEffects.filter(e => e === 'circle').length;
            let squareCount = activeEffects.filter(e => e === 'square').length;
            if (previewEffect === 'circle') circleCount++;
            if (previewEffect === 'square') squareCount++;

            // Calculate corner radius (0 = square, PLAYER_SIZE/2 = circle)
            let cornerRadius = 0;
            if (circleCount + squareCount > 0) {
                const circleRatio = circleCount / (circleCount + squareCount);
                cornerRadius = (PLAYER_SIZE / 2) * circleRatio;
            }

            // Invincibility flicker
            if (now < playerInvincibleUntil) {
                ctx.globalAlpha = 0.5 + Math.sin(now * 0.02) * 0.3;
            }

            // Draw player with rounded corners
            drawRoundedRect(playerScreenX, playerScreenY, PLAYER_SIZE, cornerRadius, recoil.x, recoil.y);
            ctx.globalAlpha = 1;

            // Muzzle flash
            if (now < muzzleFlash.until) {
                ctx.fillStyle = 'yellow';
                ctx.fillRect(playerScreenX - MUZZLE_FLASH_SIZE / 2 + muzzleFlash.offsetX, playerScreenY - MUZZLE_FLASH_SIZE / 2 + muzzleFlash.offsetY, MUZZLE_FLASH_SIZE, MUZZLE_FLASH_SIZE);
            }

            // Bullet trails (match player color)
            ctx.fillStyle = playerColor;
            for (let b of bullets) {
                for (let i = 0; i < b.trail.length; i++) {
                    const t = b.trail[i];
                    ctx.globalAlpha = (i + 1) / (b.trail.length + 1) * 0.5;
                    const size = BULLET_SIZE * (i + 1) / (b.trail.length + 1);
                    ctx.fillRect(t.x - offsetX - size / 2, t.y - offsetY - size / 2, size, size);
                }
                ctx.globalAlpha = 1;
                ctx.fillRect(b.x - offsetX - BULLET_SIZE / 2, b.y - offsetY - BULLET_SIZE / 2, BULLET_SIZE, BULLET_SIZE);
            }

            for (let e of enemies) {
                if (e.dying) {
                    const t = (now - e.deathTime) / ENEMY_DEATH_DURATION;
                    const scale = 1 + (ENEMY_DEATH_SCALE - 1) * t;
                    const size = ENEMY_SIZE * scale;
                    ctx.fillStyle = 'white';
                    ctx.fillRect(e.x - offsetX - size / 2, e.y - offsetY - size / 2, size, size);
                } else {
                    // White flash when hit
                    ctx.fillStyle = (e.hitFlashUntil && now < e.hitFlashUntil) ? 'white' : 'red';
                    ctx.fillRect(e.x - offsetX - ENEMY_SIZE / 2, e.y - offsetY - ENEMY_SIZE / 2, ENEMY_SIZE, ENEMY_SIZE);
                }
            }

            for (let f of fragments) {
                const age = now - f.birth;
                if (age < FRAGMENT_MOVE_TIME) {
                    ctx.globalAlpha = 1;
                } else {
                    ctx.globalAlpha = 1 - (age - FRAGMENT_MOVE_TIME) / FRAGMENT_FADE_TIME;
                }
                ctx.fillRect(f.x - offsetX - FRAGMENT_SIZE / 2, f.y - offsetY - FRAGMENT_SIZE / 2, FRAGMENT_SIZE, FRAGMENT_SIZE);
            }
            ctx.globalAlpha = 1;

            // Enemy bullets (red with trails)
            ctx.fillStyle = 'red';
            for (let b of enemyBullets) {
                // Draw trail
                for (let i = 0; i < b.trail.length; i++) {
                    const t = b.trail[i];
                    ctx.globalAlpha = (i + 1) / (b.trail.length + 1) * 0.5;
                    const size = ENEMY_BULLET_SIZE * (i + 1) / (b.trail.length + 1);
                    ctx.fillRect(t.x - offsetX - size / 2, t.y - offsetY - size / 2, size, size);
                }
                ctx.globalAlpha = 1;
                ctx.fillRect(b.x - offsetX - ENEMY_BULLET_SIZE / 2, b.y - offsetY - ENEMY_BULLET_SIZE / 2, ENEMY_BULLET_SIZE, ENEMY_BULLET_SIZE);
            }

            // World cards
            ctx.fillStyle = '#daa520';
            for (let c of cards) {
                ctx.fillRect(c.x - offsetX - CARD_WIDTH / 2, c.y - offsetY - CARD_HEIGHT / 2, CARD_WIDTH, CARD_HEIGHT);
            }

            ctx.restore();

            // Card viewing UI (drawn without zoom transform)
            if (viewingCard) {
                // Calculate card position and size
                let cardX, cardY, cardW, cardH;
                const targetX = canvas.width * CARD_VIEW_CARD_X - CARD_UI_WIDTH_NEW / 2;
                const targetY = canvas.height * 0.5 - CARD_UI_HEIGHT_NEW / 2;

                if (draggingCard) {
                    // Dragging: use dragPos with scaling
                    const scale = getCardScale();
                    cardW = CARD_UI_WIDTH_NEW * scale;
                    cardH = CARD_UI_HEIGHT_NEW * scale;
                    // Keep card centered on cursor
                    cardX = dragPos.x + (CARD_UI_WIDTH_NEW - cardW) / 2;
                    cardY = dragPos.y + (CARD_UI_HEIGHT_NEW - cardH) / 2;
                } else if (cardAnimation.active) {
                    // Animating from world position to UI position
                    // Start position: card's world position in screen space at animation start
                    const cardStartScreenX = cardAnimation.cardStartWorldX - player.x + cx - CARD_WIDTH / 2;
                    const cardStartScreenY = cardAnimation.cardStartWorldY - player.y + cy - CARD_HEIGHT / 2;

                    // Interpolate position
                    cardX = cardStartScreenX + (targetX - cardStartScreenX) * animProgress;
                    cardY = cardStartScreenY + (targetY - cardStartScreenY) * animProgress;

                    // Interpolate size from world card to UI card
                    cardW = CARD_WIDTH + (CARD_UI_WIDTH_NEW - CARD_WIDTH) * animProgress;
                    cardH = CARD_HEIGHT + (CARD_UI_HEIGHT_NEW - CARD_HEIGHT) * animProgress;
                } else {
                    // Resting position
                    cardX = targetX;
                    cardY = targetY;
                    cardW = CARD_UI_WIDTH_NEW;
                    cardH = CARD_UI_HEIGHT_NEW;
                }

                // Draw card
                ctx.fillStyle = '#daa520';
                ctx.fillRect(cardX, cardY, cardW, cardH);

                // Draw text only if card is large enough
                if (shouldShowCardText()) {
                    ctx.fillStyle = '#000';
                    const fontScale = cardW / CARD_UI_WIDTH_NEW;
                    ctx.font = `${Math.floor(18 * fontScale)}px monospace`;
                    ctx.fillText(viewingCard.effect.name, cardX + 15 * fontScale, cardY + 40 * fontScale);
                    ctx.font = `${Math.floor(14 * fontScale)}px monospace`;
                    ctx.fillText(viewingCard.effect.desc, cardX + 15 * fontScale, cardY + 70 * fontScale);
                }

                // Timer bar under card
                if (!cardAnimation.active && !draggingCard) {
                    const elapsed = now - cardViewStartTime;
                    const remaining = Math.max(0, 1 - elapsed / CARD_VIEW_TIMEOUT);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.fillRect(cardX, cardY + cardH + 5, cardW * remaining, 5);
                }

                // Drop zone
                ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                ctx.fillRect(0, canvas.height - 100, canvas.width, 100);
                ctx.fillStyle = '#fff';
                ctx.font = '16px monospace';
                ctx.fillText('Drag here to activate', canvas.width / 2 - 100, canvas.height - 50);
            }

            // Render activated mini-cards at bottom (always visible)
            if (activatedCards.length > 0) {
                const startX = 10;
                const y = canvas.height - MINI_CARD_SIZE - 10;
                for (let i = 0; i < activatedCards.length; i++) {
                    const card = activatedCards[i];
                    const x = startX + i * (MINI_CARD_SIZE + MINI_CARD_MARGIN);

                    // Mini card background
                    ctx.fillStyle = '#daa520';
                    ctx.fillRect(x, y, MINI_CARD_SIZE, MINI_CARD_SIZE);

                    // Letter
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 20px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(card.letter, x + MINI_CARD_SIZE / 2, y + MINI_CARD_SIZE / 2);
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'alphabetic';
                }
            }

            // Draw crosshair cursor
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            const crossSize = 10;
            ctx.beginPath();
            ctx.moveTo(mouse.x - crossSize, mouse.y);
            ctx.lineTo(mouse.x + crossSize, mouse.y);
            ctx.moveTo(mouse.x, mouse.y - crossSize);
            ctx.lineTo(mouse.x, mouse.y + crossSize);
            ctx.stroke();
        }

        function gameLoop(now) {
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            if (gameState === 'playing') {
                // Card view timeout runs even when game is paused for card view
                if (viewingCard && !draggingCard && !cardAnimation.active) {
                    if (now - cardViewStartTime > CARD_VIEW_TIMEOUT) {
                        viewingCard = null; // Discard the card
                    }
                }

                if (!viewingCard && now >= hitstopUntil) {
                    update(dt, now);
                }
                render(now);
            }

            requestAnimationFrame(gameLoop);
        }

        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
